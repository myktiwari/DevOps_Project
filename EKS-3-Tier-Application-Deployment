Overview:***
--------------
1) Ubuntu 24.04 LTS - t3a.medium (4GB RAM, 2vCore, 15GB EBS)
2) Create IAM CLI User with access & secret key
3) Install docker & give user permission
4) Install aws CLI
5) Install Kubectl & eksctl
6) Setup EKS Cluster
7) Menifest the Mongo Database
8) Menifest the Backend Application
9) Menifest the Frontend Application
10) Create Ingress Controller via helm chart (k8s package manager)
    -   Install AWS Load Balancer 
    -   Install helm chart
    -   Deploy AWS Load Balancer Controller
11) Create Ingress for routing
12) Create entry in domain provider for given domain
13) Delete the cluster (Optional)
    

STEPS:--
-------
1) Install docker & give user permission
    sudo apt-get update
    sudo apt-get install docker.io
    sudo chown $USER /var/run/docker.sock
    docker ps

cd /home/ubuntu/
git clone https://github.com/myktiwari/TWSThreeTierAppChallenge.git

Project Folder
---------------
cd TWSThreeTierAppChallenge/
Application-Code  Jenkins-Pipeline-Code  Jenkins-Server-TF  Kubernetes-Manifests-file  README.md  assets

2) Write the Dockerfile for frontend & backend application & create image from it.

cd Application-Code/frontend/
vim Dockerfile
  FROM node:14                      //pick the stable version
  WORKDIR /usr/src/app
  COPY package*.json ./
  RUN npm install
  COPY . .
  CMD [ "npm", "start" ]

docker build -t  three-tier-frontend .     // create the docker image of frontend app
docker run -itd --name frontend-app -p 3000:3000 three-tier-frontend:latest       // (Optional) test the application created from image on browser <ip>:3000

cd Application-Code/backend/
vim Dockerfile
    FROM node:14
    WORKDIR /usr/src/app
    COPY package*.json ./
    RUN npm install
    COPY . .
    CMD ["node", "index.js"]

    docker build -t three-tier-backend .     // // create the docker image of backend app

3) Install AWS CLI & configure for access & secret key***
    curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
    sudo apt install unzip
    unzip awscliv2.zip
    sudo ./aws/install -i /usr/local/aws-cli -b /usr/local/bin --update
    aws configure

4) Push the frontend & backend images on AWS ECR (Elastic Container Registry)

Amazon ECR --> Private registry --> Repositories --> Create repositories -->                               // can be create in public repo
three-tier-frontend --> View push commands --> (follow the instructions for token & authentication)
Repo link--> 637****971.dkr.ecr.us-east-1.amazonaws.com/three-tier-frontend

Amazon ECR --> Private registry --> Repositories --> Create repositories -->                               // can be create in public repo
three-tier-backend --> View push commands --> (follow the instructions for token & authentication)
Repo link --> 637****971.dkr.ecr.us-east-1.amazonaws.com/three-tier-backend

5) Install Kubectl & eksctl*** (kubectl used to control the k8s clusters while eksctl used to create the k8s cluster on EKS)
    curl -o kubectl https://amazon-eks.s3.us-west-2.amazonaws.com/1.19.6/2021-01-05/bin/linux/amd64/kubectl
    chmod +x ./kubectl
    sudo mv ./kubectl /usr/local/bin
    kubectl version --short --client
    ---
    curl --silent --location "https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz" | tar xz -C /tmp
    sudo mv /tmp/eksctl /usr/local/bin
    eksctl version

6) Setup EKS Cluster***
    eksctl create cluster --name three-tier-cluster --region us-east-1 --node-type t3a.small --nodes-min 2 --nodes-max 2
    aws eks update-kubeconfig --region us-east-1 --name three-tier-cluster
    kubectl get nodes

7) Menifest the Mongo Database***
    cd TWSThreeTierAppChallenge/Kubernetes-Manifests-file/Database/

    kubectl create namespace three-tier                              // create the namespace first
    kubectl apply -f pv.yaml                                         // create the persistante volume
    kubectl apply -f pvc.yaml                                        // claim the persistante volume
    kubectl apply -f deployment.yml                                  // create the deployment (pods)
    kubectl apply -f secrets.yml                                     // create the mongodb secrets
    kubectl apply -f service.yml                                     // create the mongodb service

    ## Now mongodb is ready to communicate with Frontend & Backend services
    Que: What is the headless service?
    Ans: ClusterIP

8) Menifest the Backend application***

cd Kubernetes-Manifests-file/Backend
vim deployment.yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata: 
      name: api
      namespace: three-tier
      labels: 
        role: api
        env: demo
    spec: 
      replicas: 2
      strategy: 
        type: RollingUpdate
        rollingUpdate:
          maxSurge: 1
          maxUnavailable: 25%
      selector: 
        matchLabels:
          role: api
      template:
        metadata:
          labels:
            role: api
        spec:
          imagePullSecrets:
          - name: ecr-registry-secret
          containers:
          - name: api
            image: 40762****962.dkr.ecr.us-east-1.amazonaws.com/backend:latest             // change the backend repo link your own
            imagePullPolicy: Always
            env:
              - name: MONGO_CONN_STR
                value: mongodb://mongodb-svc:27017/todo?directConnection=true             // match the mongodb service name as per link 
              - name: MONGO_USERNAME
                valueFrom:
                  secretKeyRef:
                    name: mongo-sec                                                       // match the mongodb secrets name
                    key: username
              - name: MONGO_PASSWORD
                valueFrom:
                  secretKeyRef:
                    name: mongo-sec
                    key: password
            ports:
            - containerPort: 3500                                                         // check the backend application port from index.js file
            livenessProbe: 
              httpGet:
                path: /ok
                port: 3500
              initialDelaySeconds: 2
              periodSeconds: 5
            readinessProbe:
              httpGet:
                path: /ok
                port: 3500
              initialDelaySeconds: 5
              periodSeconds: 5
              successThreshold: 1

vim service.yml
    apiVersion: v1
    kind: Service
    metadata:
      name: api
      namespace: three-tier
    spec: 
      ports:
      - port: 3500
        protocol: TCP
      type: ClusterIP
      selector:
        role: api

    kubectl apply -f deployment.yml
    kubectl apply -f service.yml
    kubectl get pods -n three-tier
    kubectl get deploy, svc -n three-tier
    kubectl logs <pod_id>                                                                 // check the connectivity with mongodb

9) Menifest the Frontend Application***

cd Kubernetes-Manifests-file/Frontend
vim deployment.yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: frontend
      namespace: three-tier
      labels:
        role: frontend
        env: demo
    spec: 
      replicas: 1
      strategy:
        type: RollingUpdate
        rollingUpdate:
          maxSurge: 1
          maxUnavailable: 25%
      selector:
        matchLabels: 
          role: frontend
      template:
        metadata:
          labels:
            role: frontend
        spec: 
          imagePullSecrets:
          - name: ecr-registry-secret
          containers:
          - name: frontend
            image: 4076****0962.dkr.ecr.us-east-1.amazonaws.com/frontend:latest                      // change the frontend repo link your own
            imagePullPolicy: Always
            env:
              - name: REACT_APP_BACKEND_URL
                value: "http://backend.atharvs.in/api/tasks"                                         // change the registerd url your own  
            ports:
            - containerPort: 3000                                                                    // by default react js work on port 3000

vim service.yml
    apiVersion: v1
    kind: Service
    metadata: 
      name: frontend
      namespace: three-tier
    spec:
      ports:
      - port: 3000                                                                                    // by default react js work on port 3000
        protocol: TCP
      type: ClusterIP
      selector:
        role: frontend

    kubectl apply -f deployment.yml
    kubectl apply -f service.yml
    kubectl get pods -n three-tier
    
10) Create Ingress Controller via helm chart***

i) Install AWS Load Balancer   (work: on EKS cluster level)
    curl -O https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.5.4/docs/install/iam_policy.json
    aws iam create-policy --policy-name AWSLoadBalancerControllerIAMPolicy --policy-document file://iam_policy.json
    eksctl utils associate-iam-oidc-provider --region=us-east-1 --cluster=three-tier-cluster --approve
    eksctl create iamserviceaccount --cluster=three-tier-cluster --namespace=kube-system --name=aws-load-balancer-controller --role-name AmazonEKSLoadBalancerControllerRole --attach-policy-arn=arn:aws:iam::6260*****0565:policy/AWSLoadBalancerControllerIAMPolicy --approve --region=us-east-1

ii) Deploy AWS Load Balancer Controller   (work: within EKS cluster)
    sudo snap install helm --classic
    helm repo add eks https://aws.github.io/eks-charts
    helm repo update eks
    helm repo list                                                                                  // help repository listing
    helm install aws-load-balancer-controller eks/aws-load-balancer-controller -n kube-system --set clusterName=three-tier-cluster --set serviceAccount.create=false --set serviceAccount.name=aws-load-balancer-controller
    kubectl get deployment -n kube-system aws-load-balancer-controller
    kubectl apply -f full_stack_lb.yaml

iii) Create Ingress for routing***

cd Kubernetes-Manifests-file/ingress.yaml
vim ingress.yml
    apiVersion: networking.k8s.io/v1
    kind: Ingress
    metadata:
      name: mainlb
      namespace: three-tier
      annotations:
        alb.ingress.kubernetes.io/scheme: internet-facing
        alb.ingress.kubernetes.io/target-type: ip
        alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}]'
    spec:
      ingressClassName: alb                                              // ingress class alb
      rules:
        - host: backend.atharvs.in                                       // application front url
          http:
            paths:
              - path: /api
                pathType: Prefix
                backend:
                  service:
                    name: api
                    port:   
                      number: 3500                                       // backend service running on 3500
              - path: /
                pathType: Prefix
                backend:
                  service:
                    name: frontend
                    port: 
                      number: 3000                                       // frontend service running on 3000
          
    kubectl apply -f ingress.yml
    kubectl get ing -n three-tier
    kubectl logs <mongo-db-pods-id>                                          // check the database entry

11) Delete the EKS Cluster*** (Optional)
    eksctl delete cluster --name three-tier-cluster --region us-east-1


