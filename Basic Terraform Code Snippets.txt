-------- TERRAFORM VARIABLES -----------

vim main.tf

provider "aws" {
  region = "us-east-1"
}

resource "aws_instance" "Demo" {
  ami           = var.ami
  instance_type = var.instance_type
  count         = var.total_count
  tags = {
    Name = "test_server-${count.index}"     // to print the tag with index for multiple servers
  }
}

variable.tf 

variable "ami" {
  description = "this is ami"
  type        = string
  default     = "ami-0a232144cf20a27a5"
}
variable "instance_type" {
  description = "this is instance"
  type        = string
  default     = "t3a.micro"
}
variable "total_count" {
  description = "total count 2"
  type        = number
  default     = 2
}
variable "tag_name" {
  description = "this is tag"
  type        = string
  default     = "test-server"
}


------------- TERRAFORM TFVARS ------------------

main.tf

provider "aws" {
  region = "us-east-1"
}

resource "aws_instance" "Demo" {
  ami           = var.ami
  instance_type = var.instance_type
  count         = var.total_count
  tags = {
    Name = "${var.tag_name}-${count.index}"     // to print the tag with index for multiple servers
  }
}

variable.tf

variable "ami" {}
variable "instance_type" {}
variable "total_count" {}
variable "tag_name" {}

dev.tfvars

ami = "ami-0a232144cf20a27a5"
instance_type = "t3a.micro"
total_count = 2
tag_name = "test"

terraform apply -var-file="dev.tfvars"


-------------- TERRAFORM CLI -----------------

vim main.tf

provider "aws" {
  region = "us-east-1"
}

resource "aws_instance" "Demo" {
  ami           = var.ami
  instance_type = var.instance_type
  count         = var.total_count
  tags = {
    Name = "${var.tag_name}-${count.index}"      // to print the tag with index for multiple servers
  }
}

variable "ami" { }
variable "instance_type" { }
variable "total_count" { }
variable "tag_name" { }

Note: While executing the code, it will ask to fill the value manually

terraform apply -var="instance_type=t3a.micro"


-------------------- TERRAFORM OUTPUT -----------------------

main.tf 

provider "aws" {
  region = "us-east-1"
}

resource "aws_instance" "Demo" {
  ami           = var.ami
  instance_type = var.instance_type
  tags = {
    Name = var.tag_name
  }
}

variable "ami" {
    type = string
    default = "ami-0a232144cf20a27a5"
 }
variable "instance_type" {
    type =  string
    default = "t3a.micro"
}

variable "tag_name" {
    type = string
    default = "dev"
 }

output "my_output" {
value = aws_instance.Demo.public_ip         // for single output
}

output "my_output2" {
value = [aws_instance.Demo.public_ip, aws_instance.Demo.private_ip]       // for multiple output use array
}

PART-2
-------

main.tf

provider "aws" {
  region = "us-east-1"
}

resource "aws_instance" "my_instance" {
    instance_type = var.instance_type
    ami = var.ami
    count= var.total_count
    tags = {
        Name: "${var.tag_name}-${count.index}"
    }
  }

variable "instance_type" {
  default = "t3a.micro"
}
variable "ami" {
  default = "i-04f5a78fa3dee6ac8"
}
variable "total_count" {
  default = 3
}
variable "tag_name" {
  default = "test-server"
}

output "my_output" {
  value = aws_instance.my_instance[*].public_ip      // multiple server Public Ip on single output
}

-------------------- TERRAFORM IMPORT --------------------

Import & Track the resources created manually

main.tf

provider "aws" {
  region = "us-east-1"
}

resource "aws_instance" "my_instance" {
}


terraform import aws_instance.my_instance <manual_created_instance_id>

---------- TERRAFORM RESOURCE CREATION ------------

vim main.tf 

resource "aws_instance" "my_instance" {
  ami           = var.ami
  instance_type = var.instance_type
  count         = var.total_count
  tags = {
    Name = "test_server-${count.index}"     // to print the tag with index for multiple servers
  }
}

provider "aws" {
    region = "us-east-1"
}

resource "aws_s3_bucket" "my_bucket" {
  bucket = "myktiwaribucket"
}

resource "aws_ebs_volume" "my_ebs" {
  availability_zone = "us-east-1a"
  size = 10
  tags = {
    Name= "new_ebs_volume"
  }
}

resource "aws_iam_user" "my_user" {
  name = "myktiwari"
}


------------------- TERRAFORM TAINT ---------------------

Mark resource for recreation on next apply.

terraform taint aws_instance.my_instance
terraform apply                          // It will delete the resource and recreate


------------- TERRAFORM LIFECYCLE ---------------------

vim main.tf 

provider "aws" {
    region = "us-east-1"
}

resource "aws_instance" "my_instance" {
    ami = "ami-0a232144cf20a27a5"
    instance_type = "t3a.micro"
    tags = {
      Name = "demo"
    }
  lifecycle {
    prevent_destroy = true               // It will deny to delete the instance
  }
}

------ TERRAFORM VERSION CONTRAINTS -----------

Helps to change the provider version

vim main.tf

terraform {
  required_providers {
    aws = {
      source = "hashicorp/aws"
      version = "6.10.0"
    }
  }
}

provider "aws" {
  region = "us-east-1"
}

terraform init -upgrade

------------- TERRAFORM FARMAT ----------------

Helps to write the terraform code with indentation

terraform fmt


------------------------ TERRAFORM LOCALS -------------------------

1) It's a blcok used to define values 
2) Once we define a value we can use it multipple times.
3) If you change value on local block all the values will be replaced to all block.

vim main.tf 

provider "aws" {
  region = "us-east-1"
}

locals {
  env = "dev"
}
resource "aws_vpc" "my_vpc" {
  cidr_block = "10.0.0.0/16"
  tags = {
    Name = "${local.env}-vpc"
  }
}
resource "aws_subnet" "my_subnet"{
  cidr_block = "10.0.0.0/24"
  vpc_id = aws_vpc.my_vpc.id
  availability_zone = "us-east-1b"
  tags = {
    Name = "${local.env}-subnet"
  }
}
resource "aws_instance" "my_instance" {
subnet_id = aws_subnet.my_subnet.id
ami = "ami-0a232144cf20a27a5"
instance_type = "t3a.micro"
tags = {
  Name = "${local.env}-server"
}
}

output "my_output" {
  value = aws_instance.my_instance.public_ip
}

---------------- TERRAFORM WORKSPACE ----------

1) It's a place where we write our code.
2) It is used to isloate the resources.
3) Changes in one workspace will not effect to other workspace
4) All the commands will work on workspace only.
5) In Live environment we create diff workspaces for diff envs.
6) No need to write multiple configuration files, just change the values

Workspace Commands:

terraform workspace list	            #show list of workspace
terraform workspace new dev	          #Create and switch to workspace "dev"
terraform workspace show	            #Show current workspace
terraform workspace select test	      #Switch blw workspaces
terraform workspace delete test	      #Delete the workspaces

Key-Point:

1) We cant delete current workspace.
2) Before deleting workspace we need to delete resources on it.
3) We cant delete dafault workspace

vim main.tf 

provider "aws" {
  region = "us-east-1"
}

locals {
  env = "${terraform.workspace}"
}
resource "aws_vpc" "my_vpc" {
  cidr_block = "10.0.0.0/16"
  tags = {
    Name = "${local.env}-vpc"
  }
}
resource "aws_subnet" "my_subnet"{
  cidr_block = "10.0.0.0/24"
  vpc_id = aws_vpc.my_vpc.id
  availability_zone = "us-east-1b"
  tags = {
    Name = "${local.env}-subnet"
  }
}
resource "aws_instance" "my_instance" {
subnet_id = aws_subnet.my_subnet.id
ami = "ami-0a232144cf20a27a5"
instance_type = "t3a.micro"
tags = {
  Name = "${local.env}-server"
}
}

output "my_output" {
  value = aws_instance.my_instance.public_ip
}

---------------- TERRAFORM GRAPH -----------------

Used to show the flow chart of our infra

terraform graph    // show the blueprint of current structure

https://magjac.com/graphviz-visual-editor/


------------- TERRAFORM ALIAS & PROVIDERS ----------

Create resources on multiple regions in same file.

vim main.tf

provider "aws" {
  region = "us-east-1"
}

resource "aws_instance" "us_server" {
  ami = "ami-00ca32bbc84273381"
  instance_type = "t3a.micro"
  tags = {
    Name = "test-server"
  }
}

provider "aws" {
  region = "ap-south-1"
  alias = "mumbai"          // make alias
}

resource "aws_instance" "mumbai_server" {
  provider = aws.mumbai                   // pass the alias
  ami = "ami-0861f4e788f5069dd"
  instance_type = "t3a.micro"
  tags = {
    Name = "mumbai-server"
  }
}

----------- TERRAFORM BACKEND -------------
Terraform S3 backend is used to store the Terraform state file in an S3 bucket for remote storage, collaboration, locking (with DynamoDB), and backup.
S3 backend with versioning and DynamoDB locking helps avoid accidental deletion or corruption of the state file and ensures safe collaboration.

Create the bucket :

provider "aws" {
  region = "us-east-1"
}

resource "aws_s3_bucket" "my_bucket" {
  bucket = "myktiwaribucket007"
  region = "us-east-1"
    tags = {
    Name = "backend_bucket"
    Environment = "Test"
  }
}

resource "aws_s3_bucket_versioning" "bucket_version" {
  bucket = aws_s3_bucket.my_bucket.id

  versioning_configuration {
    status = "Enabled"
  }
}

Note: remove the aws_s3_bucket from state list if required.
      terraform state rm aws_s3_bucket.my_bucket

---

provider "aws" {
  region = "us-east-1"
}

terraform {
  backend "s3" {
    bucket = "myktiwaribucket007"
    key = "test/terraform.tfstate"
    region = "us-east-1"
  }
}
 
resource "aws_instance" "my_instance" {
  ami = "ami-00ca32bbc84273381"
  instance_type = "t3a.micro"
  availability_zone = "us-east-1b"
  tags = {
    Name = "test-server"
    Environment = "Test"
  }
}

KeyPoint:
While using new block always , need to run terraform init. Otherwise plugins will not download and give error.
After removing any resource block from the code run the below command:

Exa:
Error: Backend initialization required, please run "terraform init"
Reason: Unsetting the previously set backend "s3"

Solution: terraform init -migrate-state

----- TERRAFORM REFRESH ------

terraform refresh is used to update the state file by comparing it with the real resources on the cloud
Use-Case: If any cloud resource deleted maanually from console, statefile still has a entry for that resource.
 
terraform refresh    // refresh the state list

-------- TERRAFORM LOCAL RESOURCES --------

The local resource provider in Terraform is used to run things locally on the machine where Terraform is executed, instead of provisioning cloud resources.
When using a new provider, need to initialize the plugins via terraform init.

provider "aws" {
  region = "us-east-1"
}
 
resource "local_file" "my_files" {
  filename = "test.txt"
  content = "this is local file to test the local provider"
}


